FoundationPose STEPè½¬OBJè½¬æ¢å™¨

æˆ‘å°†ä¸ºæ‚¨åˆ›å»ºä¸€ä¸ªä¸“é—¨ä¸ºNVIDIA FoundationPoseä¼˜åŒ–çš„å®Œæ•´è½¬æ¢å·¥å…·ã€‚è¿™ä¸ªå·¥å…·é›†æˆäº†STEPåˆ°OBJçš„è½¬æ¢ã€ç½‘æ ¼ä¼˜åŒ–ã€å¯è§†åŒ–ä»¥åŠFoundationPoseå…¼å®¹æ€§æ£€æŸ¥ã€‚

```python
"""
FoundationPose STEP to OBJ Converter
ä¸“ä¸ºNVIDIA FoundationPoseè®¾è®¡çš„è½¬æ¢å·¥å…·
æ”¯æŒSTEP/STPæ–‡ä»¶è½¬OBJï¼ŒåŒ…å«å¯è§†åŒ–ã€ç½‘æ ¼ä¼˜åŒ–å’Œå…¼å®¹æ€§æ£€æŸ¥
"""

import os
import sys
import argparse
import warnings
import numpy as np
from typing import Tuple, List, Optional, Dict, Any
warnings.filterwarnings('ignore')

# å°è¯•å¯¼å…¥ä¾èµ–åº“
try:
    from OCC.Core.STEPControl import STEPControl_Reader
    from OCC.Core.BRepMesh import BRepMesh_IncrementalMesh
    from OCC.Core.BRep import BRep_Tool
    from OCC.Core.TopoDS import topods_Face
    from OCC.Core.TopExp import TopExp_Explorer
    from OCC.Core.TopAbs import TopAbs_FACE
    from OCC.Core.gp import gp_Trsf
    OCC_AVAILABLE = True
except ImportError:
    print("è­¦å‘Š: pythonocc-core æœªå®‰è£…ï¼Œå°†æ— æ³•ç›´æ¥å¤„ç†STEPæ–‡ä»¶")
    print("å®‰è£…å‘½ä»¤: conda install -c conda-forge pythonocc-core=7.7.0")
    OCC_AVAILABLE = False

try:
    import pyvista as pv
    PVIZ_AVAILABLE = True
except ImportError:
    PVIZ_AVAILABLE = False

try:
    import trimesh
    TRIMESH_AVAILABLE = True
except ImportError:
    TRIMESH_AVAILABLE = False

try:
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D
    from mpl_toolkits.mplot3d.art3d import Poly3DCollection
    MATPLOTLIB_AVAILABLE = True
except ImportError:
    MATPLOTLIB_AVAILABLE = False


class STEPtoFPConverter:
    """ä¸“é—¨ä¸ºFoundationPoseä¼˜åŒ–çš„STEPè½¬OBJè½¬æ¢å™¨"""
    
    def __init__(self, verbose: bool = True):
        """
        åˆå§‹åŒ–è½¬æ¢å™¨
        
        Args:
            verbose: æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        """
        self.verbose = verbose
        self.vertices = []
        self.faces = []
        self.normals = []
        self.shape = None
        
        if not OCC_AVAILABLE:
            raise ImportError("pythonocc-coreæœªå®‰è£…ï¼Œæ— æ³•å¤„ç†STEPæ–‡ä»¶")
    
    def log(self, message: str):
        """æ‰“å°æ—¥å¿—"""
        if self.verbose:
            print(f"[STEP2FP] {message}")
    
    def read_step_file(self, step_path: str) -> bool:
        """
        è¯»å–STEPæ–‡ä»¶
        
        Args:
            step_path: STEPæ–‡ä»¶è·¯å¾„
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        if not os.path.exists(step_path):
            self.log(f"é”™è¯¯: æ–‡ä»¶ä¸å­˜åœ¨ - {step_path}")
            return False
        
        self.log(f"è¯»å–STEPæ–‡ä»¶: {step_path}")
        
        try:
            reader = STEPControl_Reader()
            status = reader.ReadFile(step_path)
            
            if status != 1:
                self.log("é”™è¯¯: æ— æ³•è¯»å–STEPæ–‡ä»¶")
                return False
            
            reader.TransferRoots()
            self.shape = reader.OneShape()
            
            if self.shape.IsNull():
                self.log("é”™è¯¯: è¯»å–çš„STEPæ–‡ä»¶ä¸ºç©º")
                return False
            
            self.log(f"STEPæ–‡ä»¶è¯»å–æˆåŠŸ")
            return True
            
        except Exception as e:
            self.log(f"è¯»å–STEPæ–‡ä»¶æ—¶å‡ºé”™: {str(e)}")
            return False
    
    def triangulate(self, 
                   linear_deflection: float = 0.01, 
                   angular_deflection: float = 0.5,
                   parallel: bool = True) -> bool:
        """
        ä¸‰è§’åŒ–BREPå½¢çŠ¶
        
        Args:
            linear_deflection: çº¿æ€§åå·®ï¼Œè¶Šå°ç²¾åº¦è¶Šé«˜
            angular_deflection: è§’åº¦åå·®ï¼Œè¶Šå°ç²¾åº¦è¶Šé«˜
            parallel: æ˜¯å¦å¹¶è¡Œè®¡ç®—
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        if self.shape is None:
            self.log("é”™è¯¯: æœªåŠ è½½STEPæ–‡ä»¶")
            return False
        
        self.log("å¼€å§‹ä¸‰è§’åŒ–...")
        
        try:
            # åˆ›å»ºç½‘æ ¼åŒ–å¯¹è±¡
            mesh = BRepMesh_IncrementalMesh(
                self.shape,
                linear_deflection,
                False,  # ä¸æ˜¯ç›¸å¯¹æ¨¡å¼
                angular_deflection,
                parallel
            )
            
            # æ‰§è¡Œç½‘æ ¼åŒ–
            mesh.Perform()
            
            if not mesh.IsDone():
                self.log("è­¦å‘Š: ç½‘æ ¼åŒ–å¯èƒ½æœªå®Œæˆ")
            
            # æå–ç½‘æ ¼æ•°æ®
            success = self._extract_mesh_data()
            
            if success:
                self.log(f"ä¸‰è§’åŒ–å®Œæˆ - é¡¶ç‚¹æ•°: {len(self.vertices)}, é¢æ•°: {len(self.faces)}")
            
            return success
            
        except Exception as e:
            self.log(f"ä¸‰è§’åŒ–æ—¶å‡ºé”™: {str(e)}")
            return False
    
    def _extract_mesh_data(self) -> bool:
        """
        ä»ä¸‰è§’åŒ–åçš„å½¢çŠ¶ä¸­æå–ç½‘æ ¼æ•°æ®
        
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        self.vertices = []
        self.faces = []
        self.normals = []
        
        try:
            # é¡¶ç‚¹æ˜ å°„å­—å…¸
            vertex_map = {}
            vertex_counter = 0
            
            # éå†æ‰€æœ‰é¢
            face_explorer = TopExp_Explorer(self.shape, TopAbs_FACE)
            
            while face_explorer.More():
                face = topods_Face(face_explorer.Current())
                triangulation = BRep_Tool.Triangulation(face, gp_Trsf())
                
                if triangulation and triangulation.NbTriangles() > 0:
                    # è·å–èŠ‚ç‚¹
                    nodes = triangulation.Nodes()
                    nb_nodes = triangulation.NbNodes()
                    
                    # å¤„ç†é¡¶ç‚¹
                    for i in range(1, nb_nodes + 1):
                        node = nodes.Value(i)
                        vertex_key = (node.X(), node.Y(), node.Z())
                        
                        if vertex_key not in vertex_map:
                            vertex_map[vertex_key] = vertex_counter
                            self.vertices.append([node.X(), node.Y(), node.Z()])
                            vertex_counter += 1
                    
                    # è·å–ä¸‰è§’å½¢
                    triangles = triangulation.Triangles()
                    nb_triangles = triangulation.NbTriangles()
                    
                    # å¤„ç†ä¸‰è§’å½¢
                    for i in range(1, nb_triangles + 1):
                        triangle = triangles.Value(i)
                        
                        # è·å–é¡¶ç‚¹ç´¢å¼•
                        idx1 = triangle.Value(1)
                        idx2 = triangle.Value(2)
                        idx3 = triangle.Value(3)
                        
                        v1 = vertex_map[(
                            nodes.Value(idx1).X(),
                            nodes.Value(idx1).Y(),
                            nodes.Value(idx1).Z()
                        )]
                        v2 = vertex_map[(
                            nodes.Value(idx2).X(),
                            nodes.Value(idx2).Y(),
                            nodes.Value(idx2).Z()
                        )]
                        v3 = vertex_map[(
                            nodes.Value(idx3).X(),
                            nodes.Value(idx3).Y(),
                            nodes.Value(idx3).Z()
                        )]
                        
                        # æ·»åŠ åˆ°é¢åˆ—è¡¨ (0-basedç´¢å¼•)
                        self.faces.append([v1, v2, v3])
                        
                        # è®¡ç®—é¢æ³•å‘é‡
                        normal = self._calculate_face_normal(
                            self.vertices[v1],
                            self.vertices[v2],
                            self.vertices[v3]
                        )
                        self.normals.append(normal)
                
                face_explorer.Next()
            
            return True
            
        except Exception as e:
            self.log(f"æå–ç½‘æ ¼æ•°æ®æ—¶å‡ºé”™: {str(e)}")
            return False
    
    def _calculate_face_normal(self, v1: List[float], v2: List[float], v3: List[float]) -> List[float]:
        """
        è®¡ç®—ä¸‰è§’å½¢é¢æ³•å‘é‡
        
        Args:
            v1, v2, v3: ä¸‰è§’å½¢é¡¶ç‚¹
            
        Returns:
            å½’ä¸€åŒ–çš„æ³•å‘é‡
        """
        # è½¬æ¢ä¸ºnumpyæ•°ç»„
        v1_np = np.array(v1)
        v2_np = np.array(v2)
        v3_np = np.array(v3)
        
        # è®¡ç®—è¾¹å‘é‡
        edge1 = v2_np - v1_np
        edge2 = v3_np - v1_np
        
        # å‰ç§¯å¾—åˆ°æ³•å‘é‡
        normal = np.cross(edge1, edge2)
        
        # å½’ä¸€åŒ–
        norm = np.linalg.norm(normal)
        if norm > 0:
            normal = normal / norm
        
        return normal.tolist()
    
    def save_obj(self, output_path: str, export_normals: bool = True) -> bool:
        """
        ä¿å­˜ä¸ºOBJæ–‡ä»¶
        
        Args:
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„
            export_normals: æ˜¯å¦å¯¼å‡ºæ³•å‘é‡
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        if not self.vertices or not self.faces:
            self.log("é”™è¯¯: æ²¡æœ‰ç½‘æ ¼æ•°æ®å¯ä¿å­˜")
            return False
        
        self.log(f"ä¿å­˜ä¸ºOBJæ–‡ä»¶: {output_path}")
        
        try:
            with open(output_path, 'w') as f:
                # å†™å…¥æ–‡ä»¶å¤´
                f.write("# OBJ file generated by FoundationPose STEP Converter\n")
                f.write(f"# Vertices: {len(self.vertices)}\n")
                f.write(f"# Faces: {len(self.faces)}\n")
                f.write(f"# For NVIDIA FoundationPose\n\n")
                
                # å†™å…¥é¡¶ç‚¹
                for v in self.vertices:
                    f.write(f"v {v[0]:.8f} {v[1]:.8f} {v[2]:.8f}\n")
                
                # å†™å…¥æ³•å‘é‡ (æ¯ä¸ªé¢ä¸€ä¸ªæ³•å‘é‡)
                if export_normals and self.normals:
                    f.write("\n# Face normals\n")
                    for n in self.normals:
                        f.write(f"vn {n[0]:.8f} {n[1]:.8f} {n[2]:.8f}\n")
                
                # å†™å…¥é¢
                f.write("\n# Faces\n")
                if export_normals and self.normals:
                    # æ¯ä¸ªé¢ä½¿ç”¨ç›¸åŒçš„æ³•å‘é‡ç´¢å¼•
                    for i, face in enumerate(self.faces):
                        f.write(f"f {face[0]+1}//{i+1} {face[1]+1}//{i+1} {face[2]+1}//{i+1}\n")
                else:
                    for face in self.faces:
                        f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")
            
            self.log(f"OBJæ–‡ä»¶ä¿å­˜æˆåŠŸ")
            return True
            
        except Exception as e:
            self.log(f"ä¿å­˜OBJæ–‡ä»¶æ—¶å‡ºé”™: {str(e)}")
            return False
    
    def get_mesh_data(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        è·å–ç½‘æ ¼æ•°æ®
        
        Returns:
            vertices: é¡¶ç‚¹æ•°ç»„ (N, 3)
            faces: é¢ç´¢å¼•æ•°ç»„ (M, 3)
        """
        vertices_array = np.array(self.vertices, dtype=np.float32)
        faces_array = np.array(self.faces, dtype=np.int32)
        
        return vertices_array, faces_array
    
    def optimize_for_foundationpose(self, 
                                   target_size: float = 1.0,
                                   compute_vertex_normals: bool = True) -> Dict[str, Any]:
        """
        ä¸ºFoundationPoseä¼˜åŒ–ç½‘æ ¼
        
        Args:
            target_size: ç›®æ ‡æ¨¡å‹å¤§å°
            compute_vertex_normals: æ˜¯å¦è®¡ç®—é¡¶ç‚¹æ³•å‘é‡
            
        Returns:
            ä¼˜åŒ–ç»Ÿè®¡ä¿¡æ¯
        """
        if not TRIMESH_AVAILABLE:
            self.log("è­¦å‘Š: trimeshæœªå®‰è£…ï¼Œæ— æ³•è¿›è¡Œé«˜çº§ä¼˜åŒ–")
            self.log("å®‰è£…å‘½ä»¤: pip install trimesh")
            return {"status": "skipped", "reason": "trimesh not available"}
        
        if not self.vertices or not self.faces:
            self.log("é”™è¯¯: æ²¡æœ‰ç½‘æ ¼æ•°æ®")
            return {"status": "error", "reason": "no mesh data"}
        
        self.log("å¼€å§‹FoundationPoseä¼˜åŒ–...")
        
        try:
            # åˆ›å»ºtrimeshå¯¹è±¡
            vertices_np = np.array(self.vertices)
            faces_np = np.array(self.faces)
            
            mesh = trimesh.Trimesh(vertices=vertices_np, faces=faces_np)
            
            # 1. ç¡®ä¿æ˜¯ä¸‰è§’ç½‘æ ¼
            if not mesh.is_empty:
                if not mesh.is_watertight:
                    self.log("è­¦å‘Š: ç½‘æ ¼ä¸æ˜¯æ°´å¯†çš„ï¼Œå¯èƒ½ä¼šå½±å“æ¸²æŸ“")
                
                # 2. è®¡ç®—é¡¶ç‚¹æ³•å‘é‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if compute_vertex_normals:
                    if mesh.vertex_normals is None or len(mesh.vertex_normals) == 0:
                        mesh.compute_vertex_normals()
                        self.log("è®¡ç®—äº†é¡¶ç‚¹æ³•å‘é‡")
                
                # 3. å½’ä¸€åŒ–å°ºå¯¸
                original_extents = mesh.extents.copy()
                
                # ç§»åŠ¨åˆ°åŸç‚¹
                mesh.apply_translation(-mesh.centroid)
                
                # è®¡ç®—ç¼©æ”¾å› å­
                max_extent = max(mesh.extents)
                if max_extent > 0:
                    scale_factor = target_size / max_extent
                    mesh.apply_scale(scale_factor)
                    
                    self.log(f"æ¨¡å‹å½’ä¸€åŒ–: åŸå§‹å°ºå¯¸ {original_extents} -> æ–°å°ºå¯¸ {mesh.extents}")
                
                # 4. æ›´æ–°æ•°æ®
                self.vertices = mesh.vertices.tolist()
                self.faces = mesh.faces.tolist()
                
                # 5. é‡æ–°è®¡ç®—é¢æ³•å‘é‡
                self.normals = []
                for face in self.faces:
                    normal = self._calculate_face_normal(
                        self.vertices[face[0]],
                        self.vertices[face[1]],
                        self.vertices[face[2]]
                    )
                    self.normals.append(normal)
                
                # 6. æ£€æŸ¥ç½‘æ ¼è´¨é‡
                stats = {
                    "status": "success",
                    "vertex_count": len(self.vertices),
                    "face_count": len(self.faces),
                    "extents": mesh.extents.tolist(),
                    "volume": mesh.volume if hasattr(mesh, 'volume') else 0,
                    "watertight": mesh.is_watertight,
                    "is_triangulated": True
                }
                
                self.log(f"ä¼˜åŒ–å®Œæˆ: {stats['vertex_count']} é¡¶ç‚¹, {stats['face_count']} é¢")
                return stats
                
        except Exception as e:
            self.log(f"ä¼˜åŒ–è¿‡ç¨‹ä¸­å‡ºé”™: {str(e)}")
            return {"status": "error", "reason": str(e)}
    
    def convert(self, 
               step_path: str, 
               output_path: Optional[str] = None,
               linear_deflection: float = 0.01,
               angular_deflection: float = 0.5,
               optimize: bool = True,
               target_size: float = 1.0) -> Optional[str]:
        """
        å®Œæ•´çš„è½¬æ¢æµç¨‹
        
        Args:
            step_path: è¾“å…¥STEPæ–‡ä»¶è·¯å¾„
            output_path: è¾“å‡ºOBJæ–‡ä»¶è·¯å¾„
            linear_deflection: çº¿æ€§åå·®
            angular_deflection: è§’åº¦åå·®
            optimize: æ˜¯å¦è¿›è¡ŒFoundationPoseä¼˜åŒ–
            target_size: ä¼˜åŒ–åçš„ç›®æ ‡å°ºå¯¸
            
        Returns:
            OBJæ–‡ä»¶è·¯å¾„ï¼Œå¤±è´¥æ—¶è¿”å›None
        """
        try:
            # 1. è¯»å–STEPæ–‡ä»¶
            if not self.read_step_file(step_path):
                return None
            
            # 2. ä¸‰è§’åŒ–
            if not self.triangulate(linear_deflection, angular_deflection):
                return None
            
            # 3. ä¼˜åŒ–ï¼ˆå¯é€‰ï¼‰
            if optimize:
                self.optimize_for_foundationpose(target_size)
            
            # 4. ç¡®å®šè¾“å‡ºè·¯å¾„
            if output_path is None:
                base_name = os.path.splitext(os.path.basename(step_path))[0]
                output_dir = "fp_models"
                os.makedirs(output_dir, exist_ok=True)
                output_path = os.path.join(output_dir, f"{base_name}.obj")
            
            # 5. ä¿å­˜OBJæ–‡ä»¶
            if not self.save_obj(output_path):
                return None
            
            return output_path
            
        except Exception as e:
            self.log(f"è½¬æ¢è¿‡ç¨‹ä¸­å‡ºé”™: {str(e)}")
            return None


class FoundationPoseValidator:
    """FoundationPoseå…¼å®¹æ€§éªŒè¯å™¨"""
    
    @staticmethod
    def validate_obj_for_foundationpose(obj_path: str) -> Dict[str, Any]:
        """
        éªŒè¯OBJæ–‡ä»¶æ˜¯å¦å…¼å®¹FoundationPose
        
        Args:
            obj_path: OBJæ–‡ä»¶è·¯å¾„
            
        Returns:
            éªŒè¯ç»“æœ
        """
        if not TRIMESH_AVAILABLE:
            return {"status": "error", "reason": "trimesh not available"}
        
        if not os.path.exists(obj_path):
            return {"status": "error", "reason": "file not found"}
        
        try:
            # åŠ è½½ç½‘æ ¼
            mesh = trimesh.load(obj_path)
            
            # æ£€æŸ¥é¡¹ç›®
            checks = {
                "æ–‡ä»¶å­˜åœ¨": True,
                "å¯ä»¥åŠ è½½": True,
                "é¡¶ç‚¹æ•°": len(mesh.vertices),
                "é¢æ•°": len(mesh.faces),
                "æ˜¯å¦ä¸‰è§’åŒ–": mesh.faces.shape[1] == 3,
                "æ˜¯å¦æœ‰é¡¶ç‚¹æ³•å‘é‡": mesh.vertex_normals is not None and len(mesh.vertex_normals) > 0,
                "æ˜¯å¦æ°´å¯†": mesh.is_watertight,
                "è¾¹ç•Œå°ºå¯¸": mesh.extents.tolist(),
                "ä½“ç§¯": mesh.volume if hasattr(mesh, 'volume') else 0,
                "æ˜¯å¦æœ‰çº¹ç†": mesh.visual.kind != 'empty'
            }
            
            # è¯„ä¼°å…¼å®¹æ€§
            compatibility = True
            issues = []
            
            if not checks["æ˜¯å¦ä¸‰è§’åŒ–"]:
                compatibility = False
                issues.append("ç½‘æ ¼ä¸æ˜¯ä¸‰è§’åŒ–ç½‘æ ¼")
            
            if not checks["æ˜¯å¦æœ‰é¡¶ç‚¹æ³•å‘é‡"]:
                issues.append("ç¼ºå°‘é¡¶ç‚¹æ³•å‘é‡ï¼ˆå¯èƒ½å½±å“æ¸²æŸ“ï¼‰")
            
            if not checks["æ˜¯å¦æ°´å¯†"]:
                issues.append("ç½‘æ ¼ä¸æ˜¯æ°´å¯†çš„ï¼ˆå¯èƒ½å½±å“æ¸²æŸ“è´¨é‡ï¼‰")
            
            # æ£€æŸ¥å°ºå¯¸æ˜¯å¦åˆç†
            max_dim = max(checks["è¾¹ç•Œå°ºå¯¸"])
            if max_dim > 10.0 or max_dim < 0.1:
                issues.append(f"æ¨¡å‹å°ºå¯¸å¯èƒ½ä¸åˆé€‚: {checks['è¾¹ç•Œå°ºå¯¸']}")
            
            checks["å…¼å®¹æ€§"] = compatibility
            checks["é—®é¢˜"] = issues
            checks["å»ºè®®"] = []
            
            # æä¾›å»ºè®®
            if not checks["æ˜¯å¦ä¸‰è§’åŒ–"]:
                checks["å»ºè®®"].append("ä½¿ç”¨mesh.triangulate()è¿›è¡Œä¸‰è§’åŒ–")
            
            if not checks["æ˜¯å¦æœ‰é¡¶ç‚¹æ³•å‘é‡"]:
                checks["å»ºè®®"].append("ä½¿ç”¨mesh.compute_vertex_normals()è®¡ç®—æ³•å‘é‡")
            
            if len(checks["å»ºè®®"]) == 0:
                checks["å»ºè®®"].append("æ¨¡å‹å·²å‡†å¤‡å¥½ç”¨äºFoundationPose")
            
            return checks
            
        except Exception as e:
            return {"status": "error", "reason": str(e)}


class MeshVisualizer:
    """ç½‘æ ¼å¯è§†åŒ–å·¥å…·"""
    
    @staticmethod
    def visualize_mesh(obj_path: str, title: str = "FoundationPose Model"):
        """
        å¯è§†åŒ–OBJç½‘æ ¼
        
        Args:
            obj_path: OBJæ–‡ä»¶è·¯å¾„
            title: å¯è§†åŒ–æ ‡é¢˜
        """
        if PVIZ_AVAILABLE:
            MeshVisualizer._visualize_with_pyvista(obj_path, title)
        elif MATPLOTLIB_AVAILABLE:
            MeshVisualizer._visualize_with_matplotlib(obj_path, title)
        else:
            print("è­¦å‘Š: æœªå®‰è£…å¯è§†åŒ–åº“ï¼Œæ— æ³•æ˜¾ç¤º3Dæ¨¡å‹")
            print("å®‰è£…å‘½ä»¤: pip install pyvista matplotlib")
    
    @staticmethod
    def _visualize_with_pyvista(obj_path: str, title: str):
        """ä½¿ç”¨PyVistaè¿›è¡Œé«˜è´¨é‡å¯è§†åŒ–"""
        try:
            import pyvista as pv
            
            print(f"ä½¿ç”¨PyVistaå¯è§†åŒ–: {obj_path}")
            
            # è¯»å–ç½‘æ ¼
            mesh = pv.read(obj_path)
            
            # åˆ›å»ºç»˜å›¾çª—å£
            plotter = pv.Plotter(window_size=[1200, 800])
            plotter.set_background('white')
            
            # æ·»åŠ ç½‘æ ¼
            plotter.add_mesh(
                mesh, 
                color='lightblue',
                show_edges=True,
                edge_color='black',
                line_width=1,
                opacity=0.9
            )
            
            # æ·»åŠ åæ ‡è½´å’Œæ ‡é¢˜
            plotter.add_axes(line_width=5)
            plotter.add_title(title, font_size=20)
            
            # æ·»åŠ ç½‘æ ¼ä¿¡æ¯æ–‡æœ¬
            info_text = f"""
            é¡¶ç‚¹æ•°: {mesh.n_points}
            é¢æ•°: {mesh.n_cells}
            å°ºå¯¸: {mesh.bounds}
            """
            plotter.add_text(info_text, position='lower_left', font_size=10)
            
            # æ˜¾ç¤º
            plotter.show()
            
        except Exception as e:
            print(f"PyVistaå¯è§†åŒ–å¤±è´¥: {e}")
            MeshVisualizer._visualize_with_matplotlib(obj_path, title)
    
    @staticmethod
    def _visualize_with_matplotlib(obj_path: str, title: str):
        """ä½¿ç”¨Matplotlibè¿›è¡ŒåŸºç¡€å¯è§†åŒ–"""
        try:
            # ç®€å•çš„OBJè¯»å–
            vertices, faces = MeshVisualizer._read_simple_obj(obj_path)
            
            if vertices is None or faces is None:
                print("æ— æ³•è¯»å–OBJæ–‡ä»¶")
                return
            
            # åˆ›å»ºå›¾å½¢
            fig = plt.figure(figsize=(10, 8))
            ax = fig.add_subplot(111, projection='3d')
            
            # ç»˜åˆ¶ç½‘æ ¼
            triangles = vertices[faces]
            mesh = Poly3DCollection(
                triangles,
                alpha=0.8,
                facecolors='lightblue',
                edgecolors='black',
                linewidths=0.5
            )
            ax.add_collection3d(mesh)
            
            # è®¾ç½®åæ ‡è½´
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')
            ax.set_title(title)
            
            # è‡ªåŠ¨è°ƒæ•´è§†å›¾
            ax.auto_scale_xyz(vertices[:, 0], vertices[:, 1], vertices[:, 2])
            
            # æ˜¾ç¤ºä¿¡æ¯
            info_text = f"é¡¶ç‚¹æ•°: {len(vertices)}\né¢æ•°: {len(faces)}"
            ax.text2D(0.05, 0.95, info_text, transform=ax.transAxes, fontsize=10,
                     verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
            
            plt.tight_layout()
            plt.show()
            
        except Exception as e:
            print(f"Matplotlibå¯è§†åŒ–å¤±è´¥: {e}")
    
    @staticmethod
    def _read_simple_obj(obj_path: str) -> Tuple[Optional[np.ndarray], Optional[np.ndarray]]:
        """ç®€å•çš„OBJæ–‡ä»¶è¯»å–å™¨"""
        vertices = []
        faces = []
        
        try:
            with open(obj_path, 'r') as f:
                for line in f:
                    if line.startswith('v '):
                        parts = line.strip().split()
                        if len(parts) >= 4:
                            vertices.append([float(parts[1]), float(parts[2]), float(parts[3])])
                    elif line.startswith('f '):
                        parts = line.strip().split()
                        face_vertices = []
                        for part in parts[1:]:
                            # å¤„ç†é¡¶ç‚¹ç´¢å¼•ï¼ˆå¯èƒ½åŒ…å«çº¹ç†/æ³•çº¿ç´¢å¼•ï¼‰
                            vertex_idx = part.split('/')[0]
                            if vertex_idx:
                                face_vertices.append(int(vertex_idx) - 1)  # è½¬ä¸º0-basedç´¢å¼•
                        
                        if len(face_vertices) >= 3:
                            # å¦‚æœæ˜¯å¤šè¾¹å½¢ï¼Œåˆ†è§£ä¸ºä¸‰è§’å½¢
                            for i in range(1, len(face_vertices) - 1):
                                faces.append([face_vertices[0], face_vertices[i], face_vertices[i+1]])
            
            return np.array(vertices), np.array(faces)
            
        except Exception as e:
            print(f"è¯»å–OBJæ–‡ä»¶æ—¶å‡ºé”™: {e}")
            return None, None


def batch_convert_for_foundationpose(input_dir: str, 
                                   output_dir: str = "foundationpose_models",
                                   pattern: str = "*.step") -> List[str]:
    """
    æ‰¹é‡è½¬æ¢STEPæ–‡ä»¶
    
    Args:
        input_dir: è¾“å…¥ç›®å½•
        output_dir: è¾“å‡ºç›®å½•
        pattern: æ–‡ä»¶åŒ¹é…æ¨¡å¼
        
    Returns:
        æˆåŠŸè½¬æ¢çš„æ–‡ä»¶åˆ—è¡¨
    """
    import glob
    
    # åˆ›å»ºè¾“å‡ºç›®å½•
    os.makedirs(output_dir, exist_ok=True)
    
    # æŸ¥æ‰¾STEPæ–‡ä»¶
    step_files = glob.glob(os.path.join(input_dir, pattern))
    step_files.extend(glob.glob(os.path.join(input_dir, "*.stp")))
    
    if not step_files:
        print(f"åœ¨ {input_dir} ä¸­æœªæ‰¾åˆ°STEPæ–‡ä»¶")
        return []
    
    print(f"æ‰¾åˆ° {len(step_files)} ä¸ªSTEPæ–‡ä»¶")
    
    # è½¬æ¢æ¯ä¸ªæ–‡ä»¶
    successful_conversions = []
    
    for i, step_file in enumerate(step_files, 1):
        print(f"\n[{i}/{len(step_files)}] å¤„ç†: {os.path.basename(step_file)}")
        
        try:
            # åˆ›å»ºè½¬æ¢å™¨
            converter = STEPtoFPConverter(verbose=True)
            
            # è½¬æ¢æ–‡ä»¶
            base_name = os.path.splitext(os.path.basename(step_file))[0]
            output_path = os.path.join(output_dir, f"{base_name}.obj")
            
            obj_path = converter.convert(
                step_path=step_file,
                output_path=output_path,
                linear_deflection=0.01,
                optimize=True
            )
            
            if obj_path and os.path.exists(obj_path):
                successful_conversions.append(obj_path)
                
                # éªŒè¯æ–‡ä»¶
                validator = FoundationPoseValidator()
                result = validator.validate_obj_for_foundationpose(obj_path)
                
                if result.get("å…¼å®¹æ€§", False):
                    print(f"  âœ… æˆåŠŸè½¬æ¢å¹¶é€šè¿‡éªŒè¯: {os.path.basename(obj_path)}")
                else:
                    print(f"  âš ï¸  æˆåŠŸè½¬æ¢ä½†æœ‰è­¦å‘Š: {os.path.basename(obj_path)}")
                    if "é—®é¢˜" in result:
                        for issue in result["é—®é¢˜"]:
                            print(f"    - {issue}")
            else:
                print(f"  âŒ è½¬æ¢å¤±è´¥: {os.path.basename(step_file)}")
                
        except Exception as e:
            print(f"  âŒ å¤„ç†å¤±è´¥: {e}")
    
    # ç”ŸæˆæŠ¥å‘Š
    if successful_conversions:
        print(f"\n{'='*60}")
        print(f"æ‰¹é‡è½¬æ¢å®Œæˆ!")
        print(f"æˆåŠŸ: {len(successful_conversions)}/{len(step_files)}")
        print(f"è¾“å‡ºç›®å½•: {output_dir}")
        print(f"{'='*60}")
        
        # ç”Ÿæˆè¯´æ˜æ–‡ä»¶
        readme_path = os.path.join(output_dir, "README_FOR_FOUNDATIONPOSE.txt")
        with open(readme_path, 'w') as f:
            f.write("="*60 + "\n")
            f.write("FoundationPose æ¨¡å‹æ–‡ä»¶è¯´æ˜\n")
            f.write("="*60 + "\n\n")
            f.write("è¿™äº›æ¨¡å‹æ–‡ä»¶å·²ç»è¿‡ä¼˜åŒ–ï¼Œå¯ç›´æ¥ç”¨äºNVIDIA FoundationPoseã€‚\n\n")
            f.write("æ¨¡å‹ç‰¹æ€§:\n")
            f.write("- å·²ä¸‰è§’åŒ–\n")
            f.write("- å°ºå¯¸å½’ä¸€åŒ–\n")
            f.write("- åŒ…å«æ³•å‘é‡\n")
            f.write("- é€‚åˆ6Då§¿æ€ä¼°è®¡\n\n")
            f.write("æ–‡ä»¶åˆ—è¡¨:\n")
            for i, model in enumerate(successful_conversions, 1):
                f.write(f"{i}. {os.path.basename(model)}\n")
            f.write("\nä½¿ç”¨æ–¹æ³•:\n")
            f.write("1. åœ¨FoundationPoseé…ç½®æ–‡ä»¶ä¸­æŒ‡å®šæ¨¡å‹è·¯å¾„\n")
            f.write("2. ç¡®ä¿æ¨¡å‹å°ºå¯¸ç¬¦åˆåœºæ™¯è¦æ±‚\n")
            f.write("3. å¦‚æœ‰éœ€è¦ï¼Œå¯è¿›ä¸€æ­¥è°ƒæ•´æè´¨å’Œçº¹ç†\n")
        
        print(f"è¯´æ˜æ–‡ä»¶å·²ç”Ÿæˆ: {readme_path}")
    
    return successful_conversions


def main():
    """ä¸»å‡½æ•° - å‘½ä»¤è¡Œæ¥å£"""
    parser = argparse.ArgumentParser(
        description="FoundationPose STEPè½¬OBJè½¬æ¢å™¨",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ç¤ºä¾‹:
  # å•ä¸ªæ–‡ä»¶è½¬æ¢
  python step2fp.py model.step -o model.obj --visualize
  
  # æ‰¹é‡è½¬æ¢ç›®å½•ä¸­çš„æ‰€æœ‰STEPæ–‡ä»¶
  python step2fp.py --batch ./step_files --output ./fp_models
  
  # é«˜ç²¾åº¦è½¬æ¢
  python step2fp.py model.step --linear 0.005 --angular 0.3
  
  # éªŒè¯OBJæ–‡ä»¶
  python step2fp.py --validate model.obj
  
  # å¯è§†åŒ–OBJæ–‡ä»¶
  python step2fp.py --visualize-only model.obj
        """
    )
    
    # è¾“å…¥å‚æ•°
    parser.add_argument("input", nargs="?", help="è¾“å…¥STEPæ–‡ä»¶æˆ–ç›®å½•")
    
    # è¾“å‡ºå‚æ•°
    parser.add_argument("-o", "--output", help="è¾“å‡ºOBJæ–‡ä»¶è·¯å¾„")
    parser.add_argument("--output-dir", default="fp_models", help="è¾“å‡ºç›®å½•ï¼ˆæ‰¹é‡è½¬æ¢æ—¶ä½¿ç”¨ï¼‰")
    
    # è½¬æ¢å‚æ•°
    parser.add_argument("--linear", type=float, default=0.01, 
                       help="çº¿æ€§åå·®ï¼ˆé»˜è®¤: 0.01ï¼Œå€¼è¶Šå°ç²¾åº¦è¶Šé«˜ï¼‰")
    parser.add_argument("--angular", type=float, default=0.5,
                       help="è§’åº¦åå·®ï¼ˆé»˜è®¤: 0.5ï¼Œå€¼è¶Šå°ç²¾åº¦è¶Šé«˜ï¼‰")
    parser.add_argument("--target-size", type=float, default=1.0,
                       help="ç›®æ ‡æ¨¡å‹å°ºå¯¸ï¼ˆé»˜è®¤: 1.0ï¼‰")
    parser.add_argument("--no-optimize", action="store_true",
                       help="ä¸è¿›è¡ŒFoundationPoseä¼˜åŒ–")
    
    # æ“ä½œæ¨¡å¼
    parser.add_argument("--batch", action="store_true",
                       help="æ‰¹é‡è½¬æ¢æ¨¡å¼ï¼ˆinputåº”ä¸ºç›®å½•ï¼‰")
    parser.add_argument("--validate", action="store_true",
                       help="éªŒè¯æ¨¡å¼ï¼ˆéªŒè¯OBJæ–‡ä»¶å…¼å®¹æ€§ï¼‰")
    parser.add_argument("--visualize", action="store_true",
                       help="è½¬æ¢åå¯è§†åŒ–æ¨¡å‹")
    parser.add_argument("--visualize-only", action="store_true",
                       help="ä»…å¯è§†åŒ–OBJæ–‡ä»¶ï¼ˆä¸è½¬æ¢ï¼‰")
    
    # å…¶ä»–å‚æ•°
    parser.add_argument("--quiet", action="store_true",
                       help="é™é»˜æ¨¡å¼ï¼Œå‡å°‘è¾“å‡º")
    
    args = parser.parse_args()
    
    # æ£€æŸ¥ä¾èµ–
    if not OCC_AVAILABLE and not (args.validate or args.visualize_only):
        print("é”™è¯¯: pythonocc-coreæœªå®‰è£…ï¼Œæ— æ³•è¿›è¡ŒSTEPè½¬æ¢")
        print("å®‰è£…å‘½ä»¤:")
        print("  conda install -c conda-forge pythonocc-core=7.7.0")
        print("æˆ–")
        print("  pip install OCC-Core==7.7.0")
        return 1
    
    # å¤„ç†ä¸åŒæ¨¡å¼
    if args.validate and args.input:
        # éªŒè¯æ¨¡å¼
        if args.input.lower().endswith(('.obj')):
            validator = FoundationPoseValidator()
            result = validator.validate_obj_for_foundationpose(args.input)
            
            print("\n" + "="*60)
            print(f"FoundationPoseå…¼å®¹æ€§éªŒè¯: {os.path.basename(args.input)}")
            print("="*60)
            
            for key, value in result.items():
                if key in ["status", "reason"]:
                    continue
                if isinstance(value, bool):
                    status = "âœ…" if value else "âŒ"
                    print(f"{status} {key}: {value}")
                elif isinstance(value, list):
                    if key == "é—®é¢˜" and value:
                        print(f"âš ï¸  {key}:")
                        for item in value:
                            print(f"    - {item}")
                    elif key == "å»ºè®®" and value:
                        print(f"ğŸ’¡ {key}:")
                        for item in value:
                            print(f"    - {item}")
                    else:
                        print(f"ğŸ“Š {key}: {value}")
                else:
                    print(f"ğŸ“Š {key}: {value}")
            
            if result.get("å…¼å®¹æ€§", False):
                print("\nğŸ‰ æ¨¡å‹å…¼å®¹FoundationPose!")
            else:
                print("\nâš ï¸  æ¨¡å‹å¯èƒ½éœ€è¦è°ƒæ•´æ‰èƒ½ç”¨äºFoundationPose")
            
            return 0
    
    elif args.visualize_only and args.input:
        # ä»…å¯è§†åŒ–æ¨¡å¼
        if args.input.lower().endswith(('.obj')):
            MeshVisualizer.visualize_mesh(args.input, "FoundationPose Model")
            return 0
        else:
            print("é”™è¯¯: è¾“å…¥æ–‡ä»¶å¿…é¡»æ˜¯OBJæ ¼å¼")
            return 1
    
    elif args.batch and args.input:
        # æ‰¹é‡è½¬æ¢æ¨¡å¼
        if os.path.isdir(args.input):
            successful = batch_convert_for_foundationpose(
                input_dir=args.input,
                output_dir=args.output_dir
            )
            return 0 if successful else 1
        else:
            print("é”™è¯¯: æ‰¹é‡æ¨¡å¼éœ€è¦è¾“å…¥ç›®å½•")
            return 1
    
    elif args.input:
        # å•ä¸ªæ–‡ä»¶è½¬æ¢æ¨¡å¼
        if not os.path.exists(args.input):
            print(f"é”™è¯¯: æ–‡ä»¶ä¸å­˜åœ¨ - {args.input}")
            return 1
        
        if args.input.lower().endswith(('.step', '.stp')):
            # åˆ›å»ºè½¬æ¢å™¨
            converter = STEPtoFPConverter(verbose=not args.quiet)
            
            # æ‰§è¡Œè½¬æ¢
            obj_path = converter.convert(
                step_path=args.input,
                output_path=args.output,
                linear_deflection=args.linear,
                angular_deflection=args.angular,
                optimize=not args.no_optimize,
                target_size=args.target_size
            )
            
            if obj_path:
                print(f"\nâœ… è½¬æ¢æˆåŠŸ: {obj_path}")
                
                # éªŒè¯æ–‡ä»¶
                validator = FoundationPoseValidator()
                result = validator.validate_obj_for_foundationpose(obj_path)
                
                print(f"\nğŸ“Š è½¬æ¢ç»Ÿè®¡:")
                print(f"  é¡¶ç‚¹æ•°: {len(converter.vertices)}")
                print(f"  é¢æ•°: {len(converter.faces)}")
                print(f"  å°ºå¯¸: {np.array(converter.vertices).max(axis=0) - np.array(converter.vertices).min(axis=0)}")
                
                if result.get("å…¼å®¹æ€§", False):
                    print("  âœ… FoundationPoseå…¼å®¹æ€§: é€šè¿‡")
                else:
                    print("  âš ï¸  FoundationPoseå…¼å®¹æ€§: æœ‰è­¦å‘Š")
                    if "é—®é¢˜" in result:
                        for issue in result["é—®é¢˜"]:
                            print(f"    - {issue}")
                
                # å¯è§†åŒ–
                if args.visualize:
                    MeshVisualizer.visualize_mesh(obj_path, "FoundationPose Model")
                
                # FoundationPoseä½¿ç”¨æç¤º
                print(f"\nğŸ¯ FoundationPoseä½¿ç”¨è¯´æ˜:")
                print(f"1. å°†æ¨¡å‹æ–‡ä»¶å¤åˆ¶åˆ°æ‚¨çš„FoundationPoseé¡¹ç›®ç›®å½•")
                print(f"2. åœ¨é…ç½®æ–‡ä»¶ä¸­æŒ‡å®šæ¨¡å‹è·¯å¾„:")
                print(f"   model:")
                print(f"     path: \"path/to/{os.path.basename(obj_path)}\"")
                print(f"     scale: 1.0  # å¦‚æœ‰éœ€è¦å¯è°ƒæ•´")
                print(f"3. ç¡®ä¿æ¨¡å‹åœ¨åœºæ™¯ä¸­çš„å°ºå¯¸åˆé€‚")
                print(f"4. å¦‚æœ‰çº¹ç†éœ€æ±‚ï¼Œå¯æ·»åŠ å¯¹åº”çš„MTLå’Œçº¹ç†æ–‡ä»¶")
                
                return 0
            else:
                print("âŒ è½¬æ¢å¤±è´¥")
                return 1
        else:
            print("é”™è¯¯: è¾“å…¥æ–‡ä»¶å¿…é¡»æ˜¯STEPæ ¼å¼ (.step, .stp)")
            return 1
    
    else:
        # æ— è¾“å…¥å‚æ•°ï¼Œæ˜¾ç¤ºå¸®åŠ©
        parser.print_help()
        
        # æ˜¾ç¤ºå®‰è£…çŠ¶æ€
        print(f"\nğŸ“¦ ä¾èµ–çŠ¶æ€:")
        print(f"  pythonocc-core: {'âœ… å·²å®‰è£…' if OCC_AVAILABLE else 'âŒ æœªå®‰è£…'}")
        print(f"  trimesh: {'âœ… å·²å®‰è£…' if TRIMESH_AVAILABLE else 'âš ï¸  æœªå®‰è£…ï¼ˆå½±å“ä¼˜åŒ–åŠŸèƒ½ï¼‰'}")
        print(f"  pyvista: {'âœ… å·²å®‰è£…' if PVIZ_AVAILABLE else 'âš ï¸  æœªå®‰è£…ï¼ˆå½±å“é«˜è´¨é‡å¯è§†åŒ–ï¼‰'}")
        print(f"  matplotlib: {'âœ… å·²å®‰è£…' if MATPLOTLIB_AVAILABLE else 'âš ï¸  æœªå®‰è£…ï¼ˆå½±å“åŸºç¡€å¯è§†åŒ–ï¼‰'}")
        
        return 0


if __name__ == "__main__":
    sys.exit(main())
```

å®‰è£…è„šæœ¬

åˆ›å»ºä¸€ä¸ªå®‰è£…è„šæœ¬æ¥ç¡®ä¿æ‰€æœ‰ä¾èµ–éƒ½æ­£ç¡®å®‰è£…ï¼š

```bash
#!/bin/bash
# install_dependencies.sh

echo "æ­£åœ¨å®‰è£… FoundationPose STEP è½¬æ¢å™¨ä¾èµ–..."

# æ£€æŸ¥condaæ˜¯å¦å¯ç”¨
if command -v conda &> /dev/null; then
    echo "ä½¿ç”¨condaå®‰è£…pythonocc-core..."
    conda install -c conda-forge pythonocc-core=7.7.0 -y
else
    echo "ä½¿ç”¨pipå®‰è£…OCC..."
    pip install OCC-Core==7.7.0
fi

# å®‰è£…å…¶ä»–ä¾èµ–
echo "å®‰è£…å…¶ä»–ä¾èµ–åº“..."
pip install numpy matplotlib pyvista trimesh

# å®‰è£…pyvistaçš„é™„åŠ ç»„ä»¶ï¼ˆå¯é€‰ï¼‰
pip install pyvistaqt  # ç”¨äºäº¤äº’å¼å¯è§†åŒ–

echo "å®‰è£…å®Œæˆï¼"
echo ""
echo "ä½¿ç”¨æ–¹æ³•ï¼š"
echo "  å•ä¸ªæ–‡ä»¶è½¬æ¢: python step2fp.py model.step -o model.obj --visualize"
echo "  æ‰¹é‡è½¬æ¢: python step2fp.py --batch ./step_files"
echo "  éªŒè¯æ¨¡å‹: python step2fp.py --validate model.obj"
```

ä½¿ç”¨ç¤ºä¾‹

1. åŸºæœ¬ä½¿ç”¨

```bash
# è½¬æ¢å•ä¸ªSTEPæ–‡ä»¶
python step2fp.py model.step -o model.obj --visualize

# é«˜ç²¾åº¦è½¬æ¢
python step2fp.py model.step --linear 0.005 --angular 0.3

# ä¸è¿›è¡Œä¼˜åŒ–ï¼ˆä¿æŒåŸå§‹å°ºå¯¸ï¼‰
python step2fp.py model.step --no-optimize
```

2. æ‰¹é‡å¤„ç†

```bash
# æ‰¹é‡è½¬æ¢ç›®å½•ä¸­çš„æ‰€æœ‰STEPæ–‡ä»¶
python step2fp.py --batch ./step_files --output-dir ./foundationpose_models
```

3. éªŒè¯å’Œå¯è§†åŒ–

```bash
# éªŒè¯OBJæ–‡ä»¶æ˜¯å¦å…¼å®¹FoundationPose
python step2fp.py --validate model.obj

# ä»…å¯è§†åŒ–OBJæ–‡ä»¶
python step2fp.py --visualize-only model.obj
```

4. åœ¨Pythonä»£ç ä¸­ä½¿ç”¨

```python
from step2fp import STEPtoFPConverter, FoundationPoseValidator, MeshVisualizer

# è½¬æ¢STEPæ–‡ä»¶
converter = STEPtoFPConverter()
obj_path = converter.convert(
    step_path="input.step",
    output_path="output.obj",
    linear_deflection=0.01,
    optimize=True
)

# éªŒè¯æ–‡ä»¶
validator = FoundationPoseValidator()
result = validator.validate_obj_for_foundationpose(obj_path)

# å¯è§†åŒ–
if result.get("å…¼å®¹æ€§", False):
    MeshVisualizer.visualize_mesh(obj_path)
```

åŠŸèƒ½ç‰¹æ€§

1. å®Œæ•´çš„STEPåˆ°OBJè½¬æ¢ï¼šæ”¯æŒæ‰€æœ‰å¸¸è§çš„STEP/STPæ–‡ä»¶æ ¼å¼
2. FoundationPoseä¼˜åŒ–ï¼š
   Â· è‡ªåŠ¨ä¸‰è§’åŒ–ç½‘æ ¼
   Â· å°ºå¯¸å½’ä¸€åŒ–
   Â· æ³•å‘é‡è®¡ç®—
   Â· å…¼å®¹æ€§æ£€æŸ¥
3. å¤šç§å¯è§†åŒ–é€‰é¡¹ï¼š
   Â· PyVistaé«˜è´¨é‡å¯è§†åŒ–
   Â· MatplotlibåŸºç¡€å¯è§†åŒ–
4. æ‰¹é‡å¤„ç†ï¼šæ”¯æŒæ‰¹é‡è½¬æ¢æ•´ä¸ªç›®å½•
5. è¯¦ç»†çš„éªŒè¯æŠ¥å‘Šï¼šæ£€æŸ¥æ¨¡å‹æ˜¯å¦é€‚åˆFoundationPose
6. å‘½ä»¤è¡Œç•Œé¢ï¼šæ˜“äºé›†æˆåˆ°å·¥ä½œæµç¨‹ä¸­

è¿™ä¸ªå·¥å…·ä¸“é—¨ä¸ºNVIDIA FoundationPoseè®¾è®¡ï¼Œç¡®ä¿ç”Ÿæˆçš„OBJæ–‡ä»¶æ»¡è¶³6Då§¿æ€ä¼°è®¡çš„è¦æ±‚ã€‚
